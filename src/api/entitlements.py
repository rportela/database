"""Firestore backed entitlement enforcement used by the API layer."""
from __future__ import annotations

from contextlib import contextmanager
from dataclasses import dataclass
from datetime import datetime, timezone
from typing import Generator, Optional

from google.cloud import firestore

from billing.models import PlanEntitlements
from billing.stripe_catalog import get_plan_by_id


@dataclass(frozen=True)
class QueryExecutionStats:
    """Represents the usage generated by a single query execution."""

    data_scanned_mb: float
    result_rows: int


class EntitlementError(RuntimeError):
    """Raised when a client exceeds its allotted quota."""


class EntitlementService:
    """Loads entitlement configuration and enforces daily limits."""

    def __init__(self, client: Optional[firestore.Client] = None) -> None:
        self._db = client or firestore.Client()

    def get_entitlements(self, client_id: str) -> PlanEntitlements:
        doc = self._db.collection("clients").document(client_id).get()
        if not doc.exists:
            raise EntitlementError(f"Client {client_id} does not exist")
        data = doc.to_dict() or {}
        entitlements_data = data.get("entitlements")
        if entitlements_data:
            return PlanEntitlements(
                max_queries_per_day=entitlements_data.get("max_queries_per_day"),
                max_scan_mb_per_day=entitlements_data.get("max_scan_mb_per_day"),
                max_concurrent_queries=entitlements_data.get("max_concurrent_queries"),
                max_result_rows=entitlements_data.get("max_result_rows"),
            )
        plan_id = data.get("plan_id")
        if not plan_id:
            raise EntitlementError(f"Client {client_id} does not have a plan assigned")
        plan = get_plan_by_id(plan_id)
        return plan.entitlements

    @contextmanager
    def query_context(self, client_id: str, *, estimated_scan_mb: float = 0.0) -> Generator[PlanEntitlements, None, None]:
        entitlements = self.get_entitlements(client_id)
        self._acquire_concurrency_slot(client_id, entitlements)
        try:
            self._precheck_usage(client_id, entitlements, estimated_scan_mb)
            yield entitlements
        finally:
            self._release_concurrency_slot(client_id, entitlements)

    def record_query_usage(
        self,
        client_id: str,
        stats: QueryExecutionStats,
        *,
        entitlements: Optional[PlanEntitlements] = None,
    ) -> None:
        entitlements = entitlements or self.get_entitlements(client_id)
        usage_ref = self._usage_document_ref(client_id)
        date_key = self._current_usage_key()

        @firestore.transactional
        def _record(transaction: firestore.Transaction) -> None:
            snapshot = usage_ref.get(transaction=transaction)
            existing = snapshot.to_dict() if snapshot.exists else {}
            queries = int(existing.get("queries", 0)) + 1
            scanned = float(existing.get("data_scanned_mb", 0.0)) + float(stats.data_scanned_mb)
            rows = int(existing.get("rows_returned", 0)) + int(stats.result_rows)

            if entitlements.max_queries_per_day is not None and queries > entitlements.max_queries_per_day:
                raise EntitlementError("Daily query allotment exhausted")
            if entitlements.max_scan_mb_per_day is not None and scanned > entitlements.max_scan_mb_per_day:
                raise EntitlementError("Daily data scan allotment exhausted")
            if entitlements.max_result_rows is not None and stats.result_rows > entitlements.max_result_rows:
                raise EntitlementError("Result row limit exceeded for plan")

            transaction.set(
                usage_ref,
                {
                    "date": date_key,
                    "queries": queries,
                    "data_scanned_mb": scanned,
                    "rows_returned": rows,
                    "updated_at": firestore.SERVER_TIMESTAMP,
                },
                merge=True,
            )

        _record(self._db.transaction())

    # Internal helpers ---------------------------------------------------

    def _precheck_usage(self, client_id: str, entitlements: PlanEntitlements, estimated_scan_mb: float) -> None:
        if entitlements.max_queries_per_day is None and entitlements.max_scan_mb_per_day is None:
            return
        usage = self._usage_document_ref(client_id).get().to_dict() or {}
        if entitlements.max_queries_per_day is not None and int(usage.get("queries", 0)) >= entitlements.max_queries_per_day:
            raise EntitlementError("Daily query allotment exhausted")
        if (
            entitlements.max_scan_mb_per_day is not None
            and float(usage.get("data_scanned_mb", 0.0)) + estimated_scan_mb > entitlements.max_scan_mb_per_day
        ):
            raise EntitlementError("Daily data scan allotment exhausted")

    def _acquire_concurrency_slot(self, client_id: str, entitlements: PlanEntitlements) -> None:
        if entitlements.max_concurrent_queries is None:
            return
        ref = self._concurrency_ref(client_id)

        @firestore.transactional
        def _acquire(transaction: firestore.Transaction) -> None:
            snapshot = ref.get(transaction=transaction)
            active = int(snapshot.to_dict().get("active", 0)) if snapshot.exists else 0
            if active >= int(entitlements.max_concurrent_queries):
                raise EntitlementError("Concurrent query limit exceeded")
            transaction.set(
                ref,
                {
                    "active": active + 1,
                    "updated_at": firestore.SERVER_TIMESTAMP,
                },
                merge=True,
            )

        _acquire(self._db.transaction())

    def _release_concurrency_slot(self, client_id: str, entitlements: PlanEntitlements) -> None:
        if entitlements.max_concurrent_queries is None:
            return
        ref = self._concurrency_ref(client_id)

        @firestore.transactional
        def _release(transaction: firestore.Transaction) -> None:
            snapshot = ref.get(transaction=transaction)
            if not snapshot.exists:
                return
            active = max(int(snapshot.to_dict().get("active", 0)) - 1, 0)
            if active == 0:
                transaction.delete(ref)
            else:
                transaction.set(
                    ref,
                    {
                        "active": active,
                        "updated_at": firestore.SERVER_TIMESTAMP,
                    },
                    merge=True,
                )

        _release(self._db.transaction())

    def _usage_document_ref(self, client_id: str) -> firestore.DocumentReference:
        date_key = self._current_usage_key()
        return (
            self._db.collection("clients")
            .document(client_id)
            .collection("usage")
            .document(date_key)
        )

    def _concurrency_ref(self, client_id: str) -> firestore.DocumentReference:
        return (
            self._db.collection("clients")
            .document(client_id)
            .collection("runtime")
            .document("concurrency")
        )

    @staticmethod
    def _current_usage_key() -> str:
        return datetime.now(timezone.utc).strftime("%Y-%m-%d")
